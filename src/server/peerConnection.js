import { db } from "../server/firebase";
import { store } from "../index";

const firepadRef = db.database().ref();

export const updatePreference = (userId, preference, roomId) => {
  const participantRef = firepadRef.child(roomId); 
  // const participantRef = updatedFirepadRef.child("participants");
  const currentParticipantRef = participantRef
    .child(userId)
    .child("preferences");
  setTimeout(() => {
    currentParticipantRef.update(preference);
  });
};

export const createOffer = async (peerConnection, receiverId, createdID, roomId) => {
  
  const participantRef = firepadRef.child(roomId); 
  // const participantRef = updatedFirepadRef.child("participants");
  const currentParticipantRef = participantRef.child(receiverId);
  peerConnection.onicecandidate = (event) => { //This sets up an event listener when ICE candidates generated by the peer connection
    event.candidate && //This part of the code checks if the event object has a valid ICE candidate
      currentParticipantRef
        .child("offerCandidates")
        .push({ ...event.candidate.toJSON(), userId: createdID });
  };
  //"offerCandidates" typically refer to the ICE candidates generated by the peer that initiated the offer.
  //"offers" typically refer to the SDP (Session Description Protocol) offer generated by the peer that initiates the communication.
  const offerDescription = await peerConnection.createOffer();
  await peerConnection.setLocalDescription(offerDescription);

  const offer = {
    sdp: offerDescription.sdp,
    type: offerDescription.type,
    userId: createdID,
  };

  await currentParticipantRef.child("offers").push().set({ offer });
};

const createAnswer = async (otherUserId, userId, roomId) => {
  //Retrieves the peer connection (pc) of the other user from the Redux store based on their ID (otherUserId).
  const pc = store.getState().participants[otherUserId].peerConnection;
  const participantRef = firepadRef.child(roomId); 
  // const participantRef = updatedFirepadRef.child("participants");
  const participantRef1 = participantRef.child(otherUserId);
  pc.onicecandidate = (event) => {
    event.candidate &&
      participantRef1
        .child("answerCandidates")
        .push({ ...event.candidate.toJSON(), userId: userId });
  };

  const answerDescription = await pc.createAnswer();
  await pc.setLocalDescription(answerDescription);

  const answer = {
    type: answerDescription.type,
    sdp: answerDescription.sdp,
    userId: userId,
  };

  await participantRef1.child("answers").push().set({ answer });
};

export const initializeListensers = async (userId, roomId) => {
  const participantRef = firepadRef.child(roomId); 
  // const participantRef = updatedFirepadRef.child("participants");
  const currentUserRef = participantRef.child(userId);

  //Sets up a listener on the offers node under the currentUserRef path. 
  //This listener is triggered whenever a new child (offer) is added to the offers node.
  currentUserRef.child("offers").on("child_added", async (snapshot) => {
    const data = snapshot.val(); //Retrieves the data (offer) associated with the newly added child node (offer)
    
    if (data?.offer) { //Checks if the received data contains an offer.
      //Retrieves the peer connection (pc) associated with the user who sent the offer. 
      //It accesses the Redux store to obtain the peer connection based on the sender's user ID (data.offer.userId).
      const pc =
        store.getState().participants[data.offer.userId].peerConnection;
      await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
      await createAnswer(data.offer.userId, userId, roomId);
    }
  });

  currentUserRef.child("offerCandidates").on("child_added", (snapshot) => {
    const data = snapshot.val();

    if (data.userId) {
      //Retrieves the peer connection (pc) associated with the user for whom the offer candidate is intended. 
      //It accesses the Redux store to obtain the peer connection based on the user ID (data.userId) extracted from the offer candidate data.
      const pc = store.getState().participants[data.userId].peerConnection;
      
      //Adds the received offer candidate to the peer connection's ICE candidate pool using the addIceCandidate() method.
      pc.addIceCandidate(new RTCIceCandidate(data));
    }
  });

  currentUserRef.child("answers").on("child_added", (snapshot) => {
    const data = snapshot.val();
    if (data?.answer) {
      const pc =
        store.getState().participants[data.answer.userId].peerConnection;
      const answerDescription = new RTCSessionDescription(data.answer);
      pc.setRemoteDescription(answerDescription);
    }
  });

  currentUserRef.child("answerCandidates").on("child_added", (snapshot) => {
    const data = snapshot.val();
    if (data.userId) {
      const pc = store.getState().participants[data.userId].peerConnection;
      pc.addIceCandidate(new RTCIceCandidate(data));
    }
  });
};


